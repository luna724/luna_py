from lunapy_module_importer import Importable
import re
import gradio as gr
from typing import *

class _lib:
  empty_variant:List[str] = [""] # var == "" の "" のすべて
  
  @staticmethod
  def re4prompt(pattern: str, text: str):
    """ コンマで区切り、対象パターンのindex0のすべてを持つリストを返す
    
    """
    prompt_piece = text.split(",")
    rtl = []
    
    for x in prompt_piece:
      x = x.strip()
      r = re.findall(pattern, x)
      if r:
        rtl.append(r[0])
    
    return rtl

  @staticmethod
  def get_value(dicts, target, rtl_if_fail="", silent=True):
    """ keyError を回避しながら辞書からの値取得を行う

    """
    if silent:
      def print(*args):
        return
    
    if not isinstance(target, str):
      return ""
    try:
      rtl = dicts[target]
    except KeyError:
      rtl = rtl_if_fail
      
      print(f"Traceback:\nKeyError: {target} in dict \n{dict}")
    return rtl

  @staticmethod
  def get_index(lists, index: int=0, rtl_if_fail="", silent=True):
    """ indexError / TypeError を回避しながらリストからの値取得を行う"""
    
    if silent:
      def print(*args):
        return
      
    if not isinstance(index, int):
      return rtl_if_fail
    
    try:
      rtl = lists[index]
    
    except IndexError:
      print(f"Traceback:\nIndexError: {index}")
      return rtl_if_fail
    
    except TypeError:
      print(f"Traceback:\nTypeError: {lists}")
      return rtl_if_fail
    
    return rtl

  @staticmethod
  def get_keys_from_dict(input_dict: dict ={}, keys_list=["", "keys"], if_fail_value=None): # 
    """This function is generated by. Colab AI
    
    KeyErrorを回避しながら辞書から複数の値の取得を行い、tuple形式で返す
    """
    return tuple(input_dict.get(key, if_fail_value) for key in keys_list)

  @staticmethod
  def get_keys_from_list(input_list: list=[], indexes_list=[0, 1], if_fail_value=None): # 
    """IndexError を回避しながらリストから複数の値の取得を行い、tuple形式で返す"""
    return tuple(_lib.get_index(input_list, key, rtl_if_fail=if_fail_value) for key in indexes_list)

  @staticmethod
  def multiple_replace(str: str, replace_key: list =[("src", "rpl")]):
    
    for x in replace_key:
      str = str.replace(x[0], x[1])
    
    return str
  
  @staticmethod
  def control_lora_weight(lora_string: str, weight: float = 1.0, loraislora:bool = False):
    # 変換
    if not isinstance(weight, float) and not isinstance(weight, int):
      weight = get_index(weight, 0, 1.0)
      
    if loraislora:
      weight = re.sub(r"<lora:.*:(.+)>", str(weight), lora_string, count=1)
      loraname = re.findall(r"<lora:(.*):.+>", lora_string)[0]
      new_lora_string = f"<lora:{loraname}:{weight}>"
      print(f"[lora Weight controller]: {lora_string} -> {new_lora_string}")
    else:
      if lora_string.count(":") > 0:
        replaced = f":{str(weight)}"
        new_lora_string = re.sub(
          r":([\d\.]+)", replaced, lora_string
        )
      else:
        new_lora_string = lora_string + f":{weight}"
      print(f"[lora Weight controller (NoLoRA Mode)]: {lora_string} -> {new_lora_string}")
    
    return new_lora_string
  
  @staticmethod
  def prompt_converter(prompt:str | List[str], separator:str = ",") -> str | List[str]:
    if isinstance(prompt, list):
      txt = ""
      for p in prompt:
        txt += p+separator
      return txt.strip(separator)
    elif isinstance(prompt, str):
      prompts = []
      for p in prompt.split(separator):
        prompts.append(
          p.strip()
        )
      return prompts
  
  @staticmethod
  def replace_variable(prompt:str, replaceFrom:str, replaceTo:str) -> str:
    prompts = _lib.prompt_converter(prompt, ",")
    via = prompts
    rpCount = prompts.count(replaceFrom)

    for index, p in enumerate(via):
      if p == replaceFrom:
        prompts[index] = replaceTo
        break 
    return _lib.prompt_converter(prompts, ", ")
  
  @staticmethod
  def comma_tweak(prompt: str) -> str:
    bad_commas = [
      ", , ", ", ,", ",, ", ",,"
    ]
    while any(s in prompt for s in bad_commas):
      for bad_comma in bad_commas:
        prompt = prompt.replace(
          bad_comma, ", "
        )
    
    return prompt
  
  @staticmethod
  def prompt_head_low(prompt:str, header:str, lower:str) -> str:
    if header.strip() != "":
      prompt = header.strip().strip(",")+", "+prompt
    if lower.strip() != "":
      if prompt.strip().endswith(","):
        end = ", "
      else:
        end = ""
      
      prompt = prompt.strip().strip(",")+", "+lower.strip().strip(",")+end
    return prompt
  
  @staticmethod
  def delete_weights(prompt_piece:str, zero:bool = False) -> str:
    if prompt_piece.count(":") > 0:
      return prompt_piece.split(":")[0]
    else:
      return prompt_piece
  
  @staticmethod
  def get_treed_value(d:dict, keys:str = "key1.key1_1", rtl_if_fail:Any = ""):
    key = keys.split(".")
    for i, k in enumerate(key):
      if k == "":
        continue
      
      if i == 0:
        value = _lib.get_value(d, k, rtl_if_fail)
      else:
        if isinstance(value, dict):
          value = _lib.get_value(value, k, rtl_if_fail)
        else:
          return rtl_if_fail
      if rtl_if_fail == value:
        return value
    
    return value
  
  @staticmethod
  def bool2visible(v:bool):
    return gr.update(visible=v)
  
class lib(Importable):
  def __init__(self):
    return
  def __call__(self, **kwargs):
    return _lib