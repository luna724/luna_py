import gradio as gr
from typing import *
from datetime import datetime
from tkinter import Tk, filedialog
from PIL import Image, ImageColor
from LGS.misc.nomore_oserror import filename_resizer
import LGS.misc.jsonconfig as jsoncfg
import re
import os
import time

from modules.shared import ROOT_DIR, language, DB_PATH, noneimg

prompt_special_words = ["(", ")", "[", "]", ""]


def multiple_replace(str: str, replace_key: list =[("src", "rpl")]):
  """

"""
  
  for x in replace_key:
    str = str.replace(x[0], x[1])
  
  return str


def re4prompt(pattern: str | Pattern[str], text: str):
  """ コンマで区切り、対象パターンのindex0のすべてを持つリストを返す
  
  """
  prompt_piece = text.split(",")
  rtl = []
  
  for x in prompt_piece:
    x = x.strip()
    r = re.findall(pattern, x)
    if r:
      rtl.append(r[0])
  
  return rtl


def mkdir(path:list, tree:bool=False, root:str=ROOT_DIR):
  """

  Args:
      path (list): os.path.join's path
      tree (bool, optional): tree mkdir. Defaults to False.
      root (str, optional): root dir. Defaults to ROOT_DIR.

  Returns:
      str: Resized path
  """
  raw_path = path
  
  path = root
  for x in raw_path:
    path = os.path.join(path, x)
    if tree:
      if not os.path.exists(path):
        os.makedirs(path, exist_ok=True)
      if not os.path.isdir(path):
        os.makedirs(path, exist_ok=True)
  
  try:
    os.makedirs(path, exist_ok=True)
  except FileNotFoundError as e:
    print(f"Catched: FileNotFoundError: {e}\n Retrying with tree=True")
    return mkdir(raw_path, True, root=root)

  return path

def browse_file():
  root = Tk()
  root.attributes("-topmost", True)
  root.withdraw()
  
  filenames = filedialog.askopenfilenames()
  if len(filenames) > 0:
      root.destroy()
      return str(filenames)
  else:
      filename = "Files not seleceted"
      root.destroy()
      return str(filename)
    
    
def keycheck(dicts, target, rtl_if_fail="", silent=True):
  """ keyError を回避しながら辞書からの値取得を行う

  """
  if silent:
    def print(*args):
      return
  
  if not isinstance(target, str):
    return ""
  try:
    rtl = dicts[target]
  except KeyError:
    rtl = rtl_if_fail
    
    print(f"Traceback:\nKeyError: {target} in dict \n{dict}")
  return rtl


def get_index(lists, index: int=0, rtl_if_fail="", silent=True):
  """ indexError / TypeError を回避しながらリストからの値取得を行う"""
  
  if silent:
    def print(*args):
      return
    
  if not isinstance(index, int):
    return rtl_if_fail
  
  try:
    rtl = lists[index]
  
  except IndexError:
    print(f"Traceback:\nIndexError: {index}")
    return rtl_if_fail
  
  except TypeError:
    print(f"Traceback:\nTypeError: {lists}")
    return rtl_if_fail
  
  return rtl


def get_keys_from_dict(input_dict: dict ={}, keys_list=["", "keys"], if_fail_value=None): # 
  """This function is generated by. Colab AI
  
  KeyErrorを回避しながら辞書から複数の値の取得を行い、tuple形式で返す
  """
  return tuple(input_dict.get(key, if_fail_value) for key in keys_list)


def get_keys_from_list(input_list: list=[], indexes_list=[0, 1], if_fail_value=None): # 
  """IndexError を回避しながらリストから複数の値の取得を行い、tuple形式で返す"""
  return tuple(get_index(input_list, key, rtl_if_fail=if_fail_value) for key in indexes_list)


def show_state_from_checkbox(status: bool):
  return gr.update(visible=status)

def resize_picture(image, w:int=None, h:int=None, color="#000000") -> Image:
  """
  image == Noneの場合 w, h, color の情報をもとに単色の指定した解像度のPIL画像を返す
  
  image == "something" の場合 imageから w, h を取得し その画像を PIL にして返す

  また、 image を指定した場合でも w, h の指定は可能。
  指定しなかった場合のみ画像から取得する
  
  Args:
      image: filepath
      w (_type_, optional): width. Defaults to None.
      h (_type_, optional): height. Defaults to None.
      color (str, optional): image color. Defaults to "black".
  """
  
  if image == None:
    if h == None and w == None:
      print("[get_bg_picture]: not enough Image opts. using 512x512")
      w, h = (512,512)
    
    elif h == None:
      h = 512
    elif w == None:
      w = 512
    res = (w, h)
    
    rgb = ImageColor.getrgb(color)
    img = Image.new(
      mode="RGB", size=res, color=rgb
    )
    
  else:
    image = Image.open(
        image, "r"
      )
    if h == None or w == None:
      w, h = image.size
    
    else:
      image = image.resize(
        (w, h)
      )
    img = image
    
  return img

def get_background_picture(i, w=None, h=None, c="#000000"):
  """
  image == Noneの場合 w, h, color の情報をもとに単色の指定した解像度のPIL画像を返す
  
  image == "something" の場合 imageから w, h を取得し その画像を PIL にして返す

  また、 image を指定した場合でも w, h の指定は可能。
  指定しなかった場合のみ画像から取得する
  
  Args:
      image: filepath
      w (_type_, optional): width. Defaults to None.
      h (_type_, optional): height. Defaults to None.
      color (str, optional): image color. Defaults to "black".
  """
  if w == 0:
    w = None
  if h == 0:
    h = None
  if i == "":
    i = None
  
  
  img = resize_picture(i, w, h, c)
  w, h = img.size
  
  # 解像度が 768x768 または同等のピクセル数を超える場合
  # 0.75 をかけ指定値までアスペクト比を維持しながら変更する
  if w * h > 589824:
    while w*h>589824:
      w /=1.5
      h /=1.5
  
  return gr.Image.update(
    value=img, height=h, width=w
  )
  
  
class time_takens:
  """
  calculate taken time with time.time() 
  
  e.g.
  time_takens = time_takens()
  
  1. time_takens.start() for start timer
  2. time_takens.wrap(text:str="") for create wrap
  3. time_takens.wait(time:float=3.0) (seconds) stop the timer for a specified time
  In fact, it only subtracts that time from the end time, it doesn't stop.
  4. time_takens.stop(time:float=3.0) .wait()'s alternate function
  5. time_takens.get(mode:Literal="estimated_time", format:bool=False) returns the currently timer's time. if format, format with .wrap()
  6. time_takens.finish(return_await:bool=False) finish timer. if return_await, returns waiting time (.await()'s total value)
  7. time_takens.yield_mode() all function will be return texts 
  
  """
  def __init__(self, yield_mode:bool=False):
    self.langs = language("/modules/lib.py", "raw")["time_takens"]
    self.yields = yield_mode
    self.waited = 0.0
    self.wraps = []
  
  
  def start(self) -> (None | str):
    """start timer"""
    self.start_time = time.time()
    if self.yields:
      return self.langs["start_timer"]
  
  
  def wrap(self, text:str="") -> (None | str):
    """create wrap.
    if you want to return text (w/o printout), use the .get()"""
    now = time.time() - self.waited
    estimated = now - self.start_time
    
    if text == "":
      text = self.langs["wrap_text"]
    else:
      if text.count("{}") < 1:
        text += "\nestimated time: {}"
    
    print(text.format(estimated))
    self.wraps.append(estimated)
    
    if self.yields:
      return text.format(estimated)
  
  
  def wait(self, time:float=3.0) -> (None):
    """stop the timer for specified time.
    values must be seconds
    """
    self.waited += time
    
    
  def stop(self, time:float=3.0) -> None:
    """stop the timer for specified time.
    values must be seconds.
    
    if self.wait() isn't Callable, it is not working
    """
    self.wait(time)
  
  
  def get(self, mode:Literal["estimated_time", "wraps"]="estimated_time", format_text:bool=False, format_target:str="Currently estimated time: {}s") -> (float | str | List[float]):
    """
    mode args:
    "estimated_time": return estimated_time. if format_text, format the format_target with estimated_time, and returns it. if not, returns estimated_time as is
    "wraps": return currently warps (list)
    
    format_target must have {} at least one.
    """
    
    if mode == "estimated_time":
      now = time.time() - self.waited
      estimated = now - self.start_time
      
      if format_text:
        return format_target.format(estimated)
      
      return estimated
    
    elif mode == "wraps":
      return self.wraps.sort()
    
    else:
      raise ValueError("mode must be ['estimated_time' or 'wraps']. but {} were given.".format(mode))
  
  
  def finish(self, round_down:int=5) -> str:
    """
    return_waits are discontinued. please remove it.
    
    finish the timer and returns time.
    round_down are used for slice
    """
    now = time.time() - self.waited
    estimated = now - self.start_time
    
    return str(estimated)[:round_down]
  
  
  def resize_estimated(self, estimated:float=0.0):
    return self.langs["resize_estimated"].format(estimated)
  
  
  def __call__(self) -> str:
    return "lunapy - SDPEM modules/lib.py:time_takens.__call__"


class override_print:
  """
  override_print:.
  Override print() function.

  Usage:
  0. initialize. variable = override_print()
  1. execute variable.get_func(header:str)
  """
  
  def __init__(self):
    self.print = print
  
  def get_func(header:str, lower:str="", end:str="\n", print_after_build:bool=False, return_resized:bool=False) -> Callable:
    """

    Args:
        header (str): text header
        lower (str, optional): text lower. Defaults to "".
        end (str, optional): print()'s end argument. Defaults to "\n".
        print_after_build (bool, optional): run print() after build the text. Defaults to False.
        return_resized (bool, optional): return resized text. Defaults to False.
    """
    h=str(header);l=str(lower);e=str(end)
    
    
    if not print_after_build:
      def override(*values:object, end=e, header=h, lower=l):
        print(header, end="")
        for x in values:
          print(x, end="")
        print(lower, end, end="")
      
    else:
      def override(*values:object, end=e, header=h, lower=l):
        text = header
        for x in values:
          text += str(x)
        text += lower
        
        print(text, end=end)
    
    if return_resized:
      def override(*values:object, end=e, header=h, lower=l):
        text = header
        for x in values:
          text += str(x)
        text += lower
        
        return text+end
    
    return override
          
      
def is_exists(target:str, trigger:str=None):
  """ text exist check. 
  args: target=parse target
  trigger=exist check target text"""
  if trigger is None:
    return False
  
  if trigger in target:
    return True
  else:
    return False


def error_handling_helper(locals:dict=None, filename:str=None) -> str:
  """how to use:
  raise ValueError(f"Exception. \nvariables save at {error_handling_helper(locals(), __name__)})
  """
  ctime = datetime.now().strftime("%Y%m%d%H%M%S")
  fp = os.path.join(ROOT_DIR, "logs", f"{ctime}_{filename}.json")
  jsoncfg.write(locals, fp)
  return fp


def int2bool(integer:int=0, trigger=[0, 1], else_block=False) -> bool:
  if integer <= trigger[0]:
    return False
  elif integer >= trigger[1]:
    return True
  
  else:
    return else_block


def save_img(path:str="relpath from shared.DB_PATH", image:Image.Image=None):
  if os.path.exists(os.path.join(DB_PATH, path)):
    print(f"Images already exist. ({path})")
    backup = os.path.join(DB_PATH, path+".old.png")
    if os.path.exists(backup):
      os.remove(backup)
    os.rename(os.path.join(DB_PATH, path), backup)
  
  image.save(
    os.path.join(DB_PATH, path))
  